/* eslint-disable import/no-internal-modules */
import * as FernNavigation from "@fern-api/fdr-sdk/navigation";
import { setMdxBundler, unsafeSerializeMdx } from "@fern-ui/ui";
import { getAuthEdgeConfig } from "@fern-ui/ui/auth";
import { getMdxBundler } from "@fern-ui/ui/bundlers";
import { NextApiHandler, NextApiRequest, NextApiResponse } from "next";
import { loadWithUrl } from "../../../../../utils/loadWithUrl";
import { getXFernHostNode } from "../../../../../utils/xFernHost";
import { getFeatureFlags } from "../../feature-flags";

export const config = {
    maxDuration: 300,
};

interface ValidationError {
    markdown: string;
    message: string;
    slug: string;
}

const handler: NextApiHandler = async (
    req: NextApiRequest,
    res: NextApiResponse<ValidationError[]>,
): Promise<unknown> => {
    try {
        // when we call res.revalidate() nextjs uses
        // req.headers.host to make the network request
        const xFernHost = getXFernHostNode(req, true);

        const authConfig = await getAuthEdgeConfig(xFernHost);

        /**
         * If the auth config is basic_token_verification, we don't need to revalidate.
         *
         * This is because basic_token_verification is a special case where all the routes are protected by a fern_token that
         * is generated by the customer, and so all routes use SSR and are not cached.
         */
        if (authConfig?.type === "basic_token_verification") {
            return res.status(200).json([]);
        }

        const docs = await loadWithUrl(xFernHost);

        if (docs == null) {
            // return notFoundResponse();
            return res.status(404).json([]);
        }

        const root = FernNavigation.utils.convertLoadDocsForUrlResponse(docs);
        const nodes: (FernNavigation.NavigationNodeWithMarkdown | FernNavigation.NavigationNodeApiLeaf)[] = [];

        FernNavigation.utils.traverseNavigation(root, (n) => {
            if (FernNavigation.hasMarkdown(n) || FernNavigation.isApiLeaf(n)) {
                nodes.push(n);
            }
        });

        const errors: ValidationError[] = [];

        const apis: Map<string, FernNavigation.ApiDefinitionHolder> = new Map();

        Object.entries(docs.definition.apis).forEach(([key, value]) => {
            apis.set(key, FernNavigation.ApiDefinitionHolder.create(value));
        });

        const featureFlags = await getFeatureFlags(xFernHost);
        setMdxBundler(await getMdxBundler(featureFlags.useMdxBundler ? "mdx-bundler" : "next-mdx-remote"));

        const collectError = async (node: FernNavigation.NavigationNodeWithMetadata, markdown: string | undefined) => {
            if (!markdown) {
                return;
            }
            try {
                await unsafeSerializeMdx(markdown);
            } catch (e) {
                errors.push({
                    markdown,
                    message: String(e),
                    slug: node.slug,
                });
            }
        };

        for (const node of nodes) {
            const pageId = FernNavigation.utils.getPageId(node);
            if (pageId != null) {
                const markdown = docs.definition.pages[pageId]?.markdown;
                await collectError(node, markdown);
            }

            if (FernNavigation.isApiLeaf(node)) {
                const api = apis.get(node.apiDefinitionId);

                if (api != null) {
                    if (node.type === "endpoint") {
                        const endpoint = api.endpoints.get(node.endpointId);
                        await collectError(node, endpoint?.description);
                        await collectError(node, endpoint?.request?.description);
                        await collectError(node, endpoint?.response?.description);
                        for (const error of endpoint?.errorsV2 ?? []) {
                            await collectError(node, error.description);
                        }
                        for (const example of endpoint?.examples ?? []) {
                            await collectError(node, example.description);
                        }
                        for (const queryParameter of endpoint?.queryParameters ?? []) {
                            await collectError(node, queryParameter.description);
                        }
                        for (const header of endpoint?.headers ?? []) {
                            await collectError(node, header.description);
                        }
                        for (const pathParameter of endpoint?.path.pathParameters ?? []) {
                            await collectError(node, pathParameter.description);
                        }
                    } else if (node.type === "webSocket") {
                        const webSocket = api.webSockets.get(node.webSocketId);
                        await collectError(node, webSocket?.description);
                        for (const event of webSocket?.messages ?? []) {
                            await collectError(node, event.description);
                        }
                        for (const example of webSocket?.examples ?? []) {
                            await collectError(node, example.description);
                        }
                        for (const queryParameter of webSocket?.queryParameters ?? []) {
                            await collectError(node, queryParameter.description);
                        }
                        for (const header of webSocket?.headers ?? []) {
                            await collectError(node, header.description);
                        }
                        for (const pathParameter of webSocket?.path.pathParameters ?? []) {
                            await collectError(node, pathParameter.description);
                        }
                    } else if (node.type === "webhook") {
                        const webhook = api.webhooks.get(node.webhookId);
                        await collectError(node, webhook?.description);
                        await collectError(node, webhook?.payload?.description);
                        for (const header of webhook?.headers ?? []) {
                            await collectError(node, header.description);
                        }
                    }
                }
            }
        }

        return res.status(200).json(errors);
    } catch (err) {
        // eslint-disable-next-line no-console
        console.error(err);
        return res.status(500).json([]);
    }
};

export default handler;
