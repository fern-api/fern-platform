import * as FernNavigation from "@fern-api/fdr-sdk/navigation";
import { NodeCollector } from "@fern-api/fdr-sdk/navigation";
import { buildUrl } from "@fern-ui/fdr-utils";
import { provideRegistryService } from "@fern-ui/ui";
import { getAuthEdgeConfig } from "@fern-ui/ui/auth";
import { NextApiHandler, NextApiRequest, NextApiResponse } from "next";
import urljoin from "url-join";
import { toValidPathname } from "../../../../utils/toValidPathname";
import { conformTrailingSlash } from "../../../../utils/trailingSlash";
import { getXFernHostNode } from "../../../../utils/xFernHost";

export const config = {
    maxDuration: 300,
};

type RevalidatePathResult = RevalidatePathSuccessResult | RevalidatePathErrorResult;

interface RevalidatePathSuccessResult {
    success: true;
    url: string;
}

interface RevalidatePathErrorResult {
    success: false;
    url: string;
    message: string;
}

type RevalidatedPaths = {
    total: number;
    data: RevalidatePathResult[];
};

const handler: NextApiHandler = async (
    req: NextApiRequest,
    res: NextApiResponse<RevalidatedPaths>,
): Promise<unknown> => {
    // when we call res.revalidate() nextjs uses
    // req.headers.host to make the network request
    const xFernHost = getXFernHostNode(req, true);
    req.headers.host = xFernHost;

    /**
     * Limit the number of paths to revalidate to max of 100.
     */
    let limit = req.query.limit == null ? 100 : parseInt(req.query.limit as string, 10);
    if (isNaN(limit) || limit < 0) {
        // eslint-disable-next-line no-console
        console.error("Invalid limit:", req.query.limit);
        return res.status(400).json({ total: 0, data: [] });
    }
    limit = Math.min(limit, 100);

    /**
     * Offset is the number of paths to skip before starting to revalidate.
     */
    const offset = req.query.offset == null ? 0 : parseInt(req.query.offset as string, 10);
    if (isNaN(offset) || offset < 0) {
        // eslint-disable-next-line no-console
        console.error("Invalid offset:", req.query.offset);
        return res.status(400).json({ total: 0, data: [] });
    }

    try {
        const authConfig = await getAuthEdgeConfig(xFernHost);

        /**
         * If the auth config is basic_token_verification, we don't need to revalidate.
         *
         * This is because basic_token_verification is a special case where all the routes are protected by a fern_token that
         * is generated by the customer, and so all routes use SSR and are not cached.
         */
        if (authConfig?.type === "basic_token_verification") {
            return res.status(200).json({ total: 0, data: [] });
        }
    } catch (err) {
        // eslint-disable-next-line no-console
        console.error(err);
        return res.status(500).json({ total: 0, data: [] });
    }

    const url = buildUrl({
        host: xFernHost,
        pathname: toValidPathname(req.query.basePath),
    });

    const docs = await provideRegistryService().docs.v2.read.getDocsForUrl({ url });

    if (!docs.ok) {
        /**
         * If the error is UnauthorizedError, we don't need to revalidate, since all the routes require SSR.
         */
        return res.status(docs.error.error === "UnauthorizedError" ? 200 : 404).json({ total: 0, data: [] });
    }

    const node = FernNavigation.utils.convertLoadDocsForUrlResponse(docs.body);
    const slugs = NodeCollector.collect(node).getPageSlugs();

    const total = slugs.length;

    const urls = slugs.slice(offset, offset + limit).map((slug) => conformTrailingSlash(urljoin(xFernHost, slug)));

    const results: RevalidatePathResult[] = await Promise.all(
        urls.map(async (url): Promise<RevalidatePathResult> => {
            // eslint-disable-next-line no-console
            console.log(`Revalidating ${url}`);
            try {
                await res.revalidate(`/static/${encodeURI(url)}`);
                return { success: true, url };
            } catch (e) {
                // eslint-disable-next-line no-console
                console.error(e);
                return { success: false, url, message: String(e) };
            }
        }),
    );

    return res.status(200).json({ total, data: results });
};

export default handler;
